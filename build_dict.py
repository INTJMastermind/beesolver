"""
Builds and updates dictionary.txt using historical answers from sbsolver.com
"""
import requests
import beesolver
import today
from bs4 import BeautifulSoup

FILENAME = 'dictionary.txt'
START = 2308
END = 2310


def load_and_prune(file):
    # Load the dictionary and remove any words <4 characters.
    print(f'Loading {file}')
    try:
        with open(file) as f:
            dictionary = set(f.read().splitlines())
    except:
        dictionary = set()
    
    len_orig = len(dictionary)
    print(f'{len_orig} words loaded')

    # Remove words <4 characters
    dictionary = {word.upper() for word in dictionary if len(word) >= 4}
    print(f'{len_orig - len(dictionary)} words <4 letters pruned.')
    print(f'New length: {len(dictionary)} words.')
    
    return dictionary

def main():
    """
    Scrapes historical answers from sbsolver.com and adds their answers to dictionary.txt
    """
    # Load a set of dictionary words with words <4 characters pruned out.
    dictionary = load_and_prune(FILENAME)

    # Creating a requests session.
    s = requests.Session()

    # Solutions are numbered numerically, i.e. "https://www.sbsolver.com/s/1234"
    URL_BASE = 'https://www.sbsolver.com/s/'
    for num in range(START,END):
        url = URL_BASE + str(num)
        try:
            print(f'\nLoading {url}')
            content = s.get(url).text
        except:
            print(f"Unable to load {url}. Aborting and saving progress!")
            break

        # Scrape the puzzle date, letters, and official answers
        date, letters, answers = today.scrape(content)
        print(f'Puzzle for {date}: {letters}')
        print(f'{len(answers)} official answers')

        # Generate our own solution set from beesolver
        solutions = beesolver.solve(letters, dictionary)
        print(f'{len(solutions)} solutions generated by beesolver')

        # Compare answers to solutions and update the dictionary.
        dictionary = today.compare(set(answers), set(solutions), dictionary)

    # We update the dictionary after grabbing a chunk of words to avoid repetitive file I/O ops.
    today.update(dictionary, FILENAME)


if __name__ == "__main__":
    main()